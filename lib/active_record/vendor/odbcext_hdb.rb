#3
#  $Id: odbcext_mysql.rb,v 1.3 2008/04/13 22:46:09 source Exp $
#
#  OpenLink ODBC Adapter for Ruby on Rails
#  Copyright (C) 2006 OpenLink Software
#
#  Permission is hereby granted, free of charge, to any person obtaining
#  a copy of this software and associated documentation files (the
#  "Software"), to deal in the Software without restriction, including
#  without limitation the rights to use, copy, modify, merge, publish,
#  distribute, sublicense, and/or sell copies of the Software, and to
#  permit persons to whom the Software is furnished to do so, subject
#  to the following conditions:
#
#  The above copyright notice and this permission notice shall be
#  included in all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
#  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
#  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
#  ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
#  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
#  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#

# INSERT INTO 'ABCDDDE'.'schema_migrations' VALUES ('dd', '20140706194119849455')
# select * from "I027910_MASTER"."apps"
# select "version" from "TESTJJ1"."schema_migrations" where "appid"='abc'
# * column name must be quated with \", not '\'
# CREATE COLUMN TABLE "I027910_MASTER"."apps" ("id" INTEGER NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "appid" VARCHAR(5000), "name" VARCHAR(5000), "desc" VARCHAR(5000), "uid" INTEGER, "created_at" SECONDDATE, "updated_at" SECONDDATE)

#require 'active_record/connection_adapters/abstract_adapter'
require 'active_record/connection_adapters/abstract/schema_definitions.rb'
require 'active_record/base.rb'
module ActiveRecord
  module ConnectionAdapters # :nodoc:
    module SchemaStatements
      def assume_migrated_upto_version(version)
        version = version.to_i
        sm_table = quote_table_name(ActiveRecord::Migrator.schema_migrations_table_name)

        migrated = select_values("SELECT 'version' FROM #{sm_table}").map(&:to_i)
        versions = Dir['db/migrate/[0-9]*_*.rb'].map do |filename|
          filename.split('/').last.split('_').first.to_i
        end

        unless migrated.include?(version)
          execute "INSERT INTO #{sm_table} (\"version\") VALUES ('#{version}')"
        end
p "versons:#{versions.inspect}, migrated:#{migrated.inspect}"
        inserted = Set.new
        (versions - migrated).each do |v|
          if inserted.include?(v)
            raise "Duplicate migration #{v}. Please renumber your migrations to resolve the conflict."
          elsif v < version
            execute "INSERT INTO #{sm_table} (\"version\") VALUES ('#{v}')"
            inserted << v
          end
        end
      end
    end #SchemaStatements
  end # ConnectionAdapters
end # ActiveRecord
module ODBCExt
  
    class HanaColumn < ActiveRecord::ConnectionAdapters::Column

    
    end #class HanaColumn
  # ------------------------------------------------------------------------
  # Mandatory methods
  #
  # The ODBCAdapter core doesn't not implement these methods
  
  # #last_insert_id must be implemented for any database which returns
  # false from #prefetch_primary_key?
  #
  # This method assumes that the table inserted into has a primary key defined
  # as INT AUTOINCREMENT
  def last_insert_id(table, sequence_name, stmt = nil)
p "last_insert_id, #{table}, #{sequence_name}"
    @logger.unknown("ODBCAdapter#last_insert_id>") if @trace
    #select_value("select LAST_INSERT_ID()", 'last_insert_id')
	if sequence_exists?(sequence_name)
          uncached do
            #select_value("SELECT #{quote_table_name(sequence_name)}.CURRVAL FROM DUMMY")
            select_value("SELECT #{quote_table_name(sequence_name)}.NEXTVAL FROM DUMMY")
           
            select_value("SELECT #{quote_table_name(sequence_name)}.CURRVAL FROM DUMMY")
          end
	elsif has_column?(table, "ID")
	    return select_value("select max(ID) from #{quote_table_name(table)}")
    else 
        return nil
	end
  end
  
  # ------------------------------------------------------------------------
  # Optional methods
  #
  # These are supplied for a DBMS only if necessary.
  # ODBCAdapter tests for optional methods using Object#respond_to?
  
  # Pre action for ODBCAdapter#insert
  # def pre_insert(sql, name, pk, id_value, sequence_name)
  # end
  
  # Post action for ODBCAdapter#insert
  # def post_insert(sql, name, pk, id_value, sequence_name)
  # end
  
  # ------------------------------------------------------------------------
  # Method redefinitions
  #
  # DBMS specific methods which override the default implementation 
  # provided by the ODBCAdapter core.
  
  def quote_string(string)
    @logger.unknown("ODBCAdapter#quote_string>") if @trace
    
    # MySQL requires backslashes to be escaped				
    string.gsub(/\\/, '\&\&').gsub(/'/, "''")
  end
  
  def create_database(name)
    @logger.unknown("ODBCAdapter#create_database>") if @trace
    @logger.unknown("args=[#{name}]") if @trace    
    execute "CREATE DATABASE `#{name}`"
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise    
  end

  def drop_table(name, options={})
p "===> drop hana table #{name}"
	
    #execute "DROP TABLE #{quote_column_name(@connection_options[:schema])+"."+quote_column_name(name)} IF EXISTS #{quote_column_name(name)}"
	# hana do not supoort 'if exists'
	if @connection_options[:schema] && @connection_options[:schema] != ""
    execute "DROP TABLE #{quote_column_name(@connection_options[:schema])+"."+quote_column_name(name)} "
else
    execute "DROP TABLE #{quote_column_name(name)} "
end
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise
  end

  def drop_database(name)
    @logger.unknown("ODBCAdapter#drop_database>") if @trace
    @logger.unknown("args=[#{name}]") if @trace    
    execute "DROP DATABASE IF EXISTS `#{name}`"
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise    
  end
=begin  
  def create_table(name, options = {})
	p "==>create hdb table"
        begin
            raise Exception.new
        rescue Exception=>e
	stack = 100
            if e.backtrace.size >=2 && stack >= 0
                stack  += 1
                stack = e.backtrace.size-1 if stack >= e.backtrace.size
                p e.backtrace[1..stack].join("
") 
	
            end
	    
        end
    @logger.unknown("ODBCAdapter#create_table>") if @trace
    super(name, options)
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise
  end
=end
        def default_table_type
          "COLUMN"
        end
        def generic_table_definition(adapter = nil, table_name = nil, is_temporary = nil, options = {})
          if ::ActiveRecord::VERSION::MAJOR >= 4
            ActiveRecord::ConnectionAdapters::TableDefinition.new(native_database_types, table_name, is_temporary, options)
          else
            ActiveRecord::ConnectionAdapters::TableDefinition.new(adapter)
          end
        end
        def create_table(table_name, options = {})
          td = generic_table_definition(self, table_name, options[:temporary], options[:options])
          td.primary_key(options[:primary_key] || Base.get_primary_key(table_name.to_s.singularize)) unless options[:id] == false

          yield td if block_given?

          if options[:force] && table_exists?(table_name)
            drop_table(table_name, options)
          end
                    
          create_sequence(default_sequence_name(table_name, nil))
          if ::ActiveRecord::VERSION::MAJOR >= 4
            create_sql = schema_creation.accept td
          else  
            create_sql = "CREATE TABLE "
            create_sql << "#{quote_table_name(table_name)} ("
            create_sql << td.to_sql
            create_sql << ") #{options[:options]}"
          end
                        
          if options[:row]
            create_sql.insert(6," ROW")
          elsif options[:column]
            create_sql.insert(6," COLUMN")
          elsif options[:history]
            create_sql.insert(6," HISTORY COLUMN")
          elsif options[:global_temporary]
            create_sql.insert(6," GLOBAL TEMPORARY")
          elsif options[:local_temporary]
            create_sql.insert(6," GLOBAL LOCAL")
          else
            create_sql.insert(6," #{default_table_type}")
          end

            execute create_sql

          if ::ActiveRecord::VERSION::MAJOR >= 4
            td.indexes.each_pair { |c,o| add_index table_name, c, o }
          end   
                    
        end
  
  def rename_table(name, new_name)
    @logger.unknown("ODBCAdapter#rename_table>") if @trace
    execute "RENAME TABLE #{name} TO #{new_name}"
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise
  end
  
  def change_column(table_name, column_name, type, options = {})
    @logger.unknown("ODBCAdapter#change_column>") if @trace
    # column_name.to_s used in case column_name is a symbol
    unless options_include_default?(options)
      options[:default] = columns(table_name).find { |c| c.name == column_name.to_s }.default    
    end
    change_column_sql = "ALTER TABLE #{table_name} CHANGE #{column_name} #{column_name} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
    add_column_options!(change_column_sql, options)
    execute(change_column_sql)
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise  
  end

  def rename_column(table_name, column_name, new_column_name)
    @logger.unknown("ODBCAdapter#rename_column>") if @trace
    col = columns(table_name).find{ |c| c.name == column_name.to_s }
    current_type = col.sql_type
    current_type << "(#{col.limit})" if col.limit
    execute "ALTER TABLE #{table_name} CHANGE #{column_name} #{new_column_name} #{current_type}"
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise
  end
  
  def change_column_default(table_name, column_name, default)
    @logger.unknown("ODBCAdapter#change_column_default>") if @trace
    col = columns(table_name).find{ |c| c.name == column_name.to_s }
    change_column(table_name, column_name, col.type, :default => default,
      :limit => col.limit, :precision => col.precision, :scale => col.scale)
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise
  end
  
  def indexes(table_name, name = nil)
    # Skip primary key indexes
    super(table_name, name).delete_if { |i| i.unique && i.name =~ /^PRIMARY$/ }
  end

  def options_include_default?(options)
    # MySQL 5.x doesn't allow DEFAULT NULL for first timestamp column in a table
    if options.include?(:default) && options[:default].nil?
      if options.include?(:column) && options[:column].sql_type =~ /timestamp/i
        options.delete(:default)
      end
    end
    super(options)
  end
  
  def disable_referential_integrity(&block) #:nodoc:
    old = select_value("SELECT @@FOREIGN_KEY_CHECKS")
    begin
      update("SET FOREIGN_KEY_CHECKS = 0")
      yield
    ensure
      update("SET FOREIGN_KEY_CHECKS = #{old}")
    end
  end
          
  def structure_dump
    @logger.unknown("ODBCAdapter#structure_dump>") if @trace
    select_all("SHOW TABLES").inject("") do |structure, table|
      structure += select_one("SHOW CREATE TABLE #{table.to_a.first.last}")["Create Table"] + ";\n\n"
    end
  rescue Exception => e
    @logger.unknown("exception=#{e}") if @trace
    raise
  end
        # Returns a quoted form of the column name.
        def quote_column_name(name)
p "quote column name #{name}"
          @logger.unknown("ODBCAdapter#quote_column_name>") if @trace
          @logger.unknown("args=[#{name}]") if @trace
          name = name.to_s if name.class == Symbol
           if name.class == String
              name = name.upcase
          elsif name.class == Array
              name.map!(&:upcase)
          end
          idQuoteChar = @dsInfo.info[ODBC::SQL_IDENTIFIER_QUOTE_CHAR]
p "00ODBC::SQL_IDENTIFIER_QUOTE_CHAR=#{idQuoteChar}"
          return name if !idQuoteChar || ((idQuoteChar = idQuoteChar.strip).length == 0)
          idQuoteChar = idQuoteChar[0]

p "1ODBC::SQL_IDENTIFIER_QUOTE_CHAR=#{idQuoteChar}"
          # Avoid quoting any already quoted name
          return name if name[0] == idQuoteChar && name[-1] == idQuoteChar

p "11DBC::SQL_IDENTIFIER_CASE=#{@dsInfo.info[ODBC::SQL_IDENTIFIER_CASE]}, ODBC::SQL_IC_UPPER=>#{ODBC::SQL_IC_UPPER}"
          # If DBMS's SQL_IDENTIFIER_CASE = SQL_IC_UPPER, only quote mixed 
          # case names.
          # See #dbmsIdentCase for the identifier case conventions used by this
          # adapter.
          #if @dsInfo.info[ODBC::SQL_IDENTIFIER_CASE] == ODBC::SQL_IC_UPPER
           # return name unless (name =~ /([A-Z]+[a-z])|([a-z]+[A-Z])/)
         # end

p "12DBC::SQL_IDENTIFIER_QUOTE_CHAR=#{idQuoteChar}"
          idQuoteChar.chr + name + idQuoteChar.chr
        end
          
        def quote_table_name(name)
          @logger.unknown("ODBCAdapter#quote_table_name>") if @trace
          @logger.unknown("args=[#{name}]") if @trace
	  if @connection_options[:schema] && @connection_options[:schema] != ""
          quote_column_name(@connection_options[:schema])+"."+quote_column_name(name)
	else
          quote_column_name(name)
	end

        end
	
	def table_filter(schemaName, tblName, tblType)
	#	p "schema #{schemaName} #{@connection_options[:schema]}"
		@connection_options[:schema].upcase == schemaName.upcase		
	end
        def tables1(name = nil)
p "show hdb tables, schema=#{@connection_options[:schema]}"
          @logger.unknown("ODBCAdapter#tables>") if @trace
          @logger.unknown("args=[#{name}]") if @trace
          tblNames = []
          # TODO: ODBC::Connection#tables cannot filter on schema name
          # Modify Werner's Ruby ODBC driver to allow this
          currentUser = @dsInfo.info[ODBC::SQL_USER_NAME]
          stmt = @connection.tables
          resultSet = stmt.fetch_all || []
	 p "resultset size #{resultSet.size}"
          resultSet.each do |row|
            schemaName = row[1]
            tblName = row[2]
            tblType = row[3]
   #p "schemaName0=#{schemaName}, currentUser=#{currentUser}"
            if !respond_to?("table_filter") or table_filter(schemaName, tblName, tblType)
            	#if @dbmsLookups.get_info(@dbmsName, @dbmsMajorVer, :supports_schema_names)
   #p "schemaName1=#{schemaName}, currentUser=#{currentUser}"
              	#	tblNames << activeRecIdentCase(tblName) if schemaName.casecmp(currentUser) == 0
            	#else
   #           		tblNames << activeRecIdentCase(tblName)
            	#end
		tblNames << activeRecIdentCase(tblName)
	    end
          end
          stmt.drop
          tblNames
        rescue Exception => e
          @logger.unknown("exception=#{e}") if @trace
#          raise ActiveRecordError, e.message
	
        end
	def schema
		@connection_options[:schema]
	end

# from Active Record HANA Adapter

        # === Sequences ======================================== #

        def create_sequence(sequence, options = {})
          create_sql = "CREATE SEQUENCE #{quote_table_name(sequence)} INCREMENT BY 1 START WITH 1 NO CYCLE"
          execute create_sql                
	      select_value("SELECT #{quote_table_name(sequence)}.NEXTVAL FROM DUMMY")
        end

        def rename_sequence(table_name, new_name)
          rename_sql =  "CREATE SEQUENCE #{quote_table_name(default_sequence_name(new_name, nil))} "
          rename_sql << "INCREMENT BY 1 "
          rename_sql << "START WITH #{next_sequence_value(default_sequence_name(table_name, nil))} NO CYCLE"
          execute rename_sql

          drop_sequence(default_sequence_name(table_name, nil))
        end

        def drop_sequence(sequence)
          execute "DROP SEQUENCE #{quote_table_name(sequence)}"     
        end
        # === Tables =========================================== #              

	def tables
          select_values "SELECT TABLE_NAME FROM TABLES WHERE SCHEMA_NAME=\'#{@connection_options[:database]}\'", 'SCHEMA'
        end
          def unqualify_table_name(table_name)
            table_name.to_s.split('.').last.tr('[]','')
          end
        def table_exists?(table_name)
          return false if table_name.blank?
          
          unquoted_table_name = unqualify_table_name(table_name)
          super || tables.include?(unquoted_table_name) || views.include?(unquoted_table_name)
        end
        def table_structure(table_name)
          returning structure = select_rows("SELECT COLUMN_NAME, DEFAULT_VALUE, DATA_TYPE_NAME, IS_NULLABLE FROM TABLE_COLUMNS WHERE SCHEMA_NAME=\'#{@connection_options[:database]}\' AND TABLE_NAME=\'#{table_name}\'") do
            raise(ActiveRecord::StatementInvalid, "Could not find table '#{table_name}'") if structure.empty?
          end
        end
        # === Columns ========================================== #

        def columns(table_name, name = nil)
p "columns for table #{table_name}, #{name}..."
          return [] if table_name.blank?

          table_structure(table_name).map do |column|
            HanaColumn.new column[0], column[1], column[2], column[3]
          end
        end

        def add_column(table_name, column_name, type, options = {})
          add_column_sql = "ALTER TABLE #{quote_table_name(table_name)} ADD ( #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])}"
          add_column_options!(add_column_sql, options)
          add_column_sql << ")"
          execute(add_column_sql)
        end
        def has_column?(table_name, column_name)
            columns(table_name).find { |c| c.name == column_name.to_s } == nil
        end

        def change_column(table_name, column_name, type, options = {})
          execute "ALTER TABLE #{quote_table_name(table_name)} ALTER (#{quote_column_name(column_name)} #{type_to_sql(type, options[:limit], options[:precision], options[:scale])})"
        end

        def change_column_default(table_name, column_name, default)
          execute "ALTER TABLE #{quote_table_name(table_name)} ALTER (#{quote_column_name(column_name)} DEFAULT #{quote(default)})"
        end

        def rename_column(table_name, column_name, new_column_name)
          execute "RENAME COLUMN #{quote_table_name(table_name)}.#{quote_column_name(column_name)} TO #{quote_column_name(new_column_name)}"
        end

        def remove_column(table_name, *column_names)
          if column_names.flatten!
            message = 'Passing array to remove_columns is deprecated, please use ' +
                      'multiple arguments, like: `remove_columns(:posts, :foo, :bar)`'
            ActiveSupport::Deprecation.warn message, caller
          end

          columns_for_remove(table_name, *column_names).each do |column_name|
            execute "ALTER TABLE #{quote_table_name(table_name)} DROP (#{column_name})"
          end
        end
        
        alias :remove_columns :remove_column

        def remove_default_constraint(table_name, column_name)
          execute "ALTER TABLE #{quote_table_name(table_name)} DROP CONSTRAINT #{default_constraint_name(table_name, column_name)}"
        end

        # === Views ============================================ #
                
        def views
          select_values "SELECT VIEW_NAME FROM VIEWS WHERE SCHEMA_NAME=\'#{@connection_options[:database]}\'", 'SCHEMA'
        end
	
	def sequences
	  select_values "SELECT SEQUENCE_NAME FROM SEQUENCES WHERE SCHEMA_NAME=\'#{@connection_options[:database]}\'", "SCHEMA"
	end
        def sequence_exists?(sequence_name)
          return false if sequence_name.blank?

          unquoted_table_name = unqualify_table_name(sequence_name)
          p "find seq #{unquoted_table_name}"
          p "sequences:#{sequences.inspect}"
          
          sequences.include?(unquoted_table_name) 
        end
end
